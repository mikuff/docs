## 面向对象
> 面向对象编程是一种实现的方法，在这种方法中，程序被组织成许多组相互协作的对象，每个对象代表某个类的一个实例，而类则属于一个通过继承关系形成的层次结构。  
- 利用对象作为面向对象编程的基本逻辑构建块
- 每个对象都是某个类的一个实例
- 类与类之间可以通过继承关系联系在一起

> 面向对象设计是一种设计方法，包括面向对象分解的过程和一种表示法，这种表示法用于展现被设计系统的逻辑模型和物理模型、静态模型和动态模型。  
- 面向对象设计导致了面向对象分解
- 面向对象设计使用了不同的表示法来表达系统逻辑设计（类和对象结构）和物理设计（模块和处理架构）的不同模型，以及系统的静态和动态特征

> 对面向对象分解的支持是面向对象设计与结构化设计的不同之处：**前者利用类和对象抽象来构建逻辑系统结构，后者则利用算法抽象。**我们用术语“面向对象设计”来指所有导致面向对象分解的方法。

## 对象模型要素
### 抽象
> **抽象描述了一个对象的基本特征，可以将这个对象与所有其他类型的对象区分开来，因此提供了清晰定义的概念边界，它与观察者的视角有关**

> 抽象关注一个对象的外部视图，所以可以用来分离对象的基本行为和它的实现。Abelson和Sussman将这种行为/实现的分界称为抽象壁垒，它是通过应用“最少承诺”原则来达成的。根据这个原则，对象的接口只提供它的基本行为，此外别无其他。我们还想使用另一个原则，我们称之为“最少惊奇”原则，这个原则是指抽象捕捉了某个对象的全部行为，不多也不少，并且不提供抽象之外的惊奇效果或副作用。
" 从那些准确地为问题域实体建模的对象到那些实际上没有什么理由存在的对象，存在着一系列的抽象。"按最有用到最没有用的次序，这些抽象是：
- 实体抽象 一个对象，代表了问题域或解决方案域实体的一个有用的模型
- 动作抽象 一个对象，提供了一组通用的操作，所有这些操作都执同类的功能
- 虚拟机抽象 一个对象，集中了某种高层控制要用到的所有操作，或者这些操作将利用某种更低层的操作集
- 偶然抽象 一个对象，封装了一组相互间没有关系的操作
> 我们追求构建实体抽象，因为它们直接对应着给定问题域的词汇。  
客户对象是使用其他对象（称为服务器对象）的资源的对象。可以通过考虑对象提供给其他对象的服务来总结一个对象的行为，以及它可能施加在其他对象上的操作。这种视角迫使我们集中关注对象的外部视图，导致了Meyer所谓的“编程契约模型”：每个对象的外部视图定义了一份契约，其他对象可以依赖这份契约，而该对象则需要通过它的内部视图来实现这份契约（常常需要与其他对象协作）。这份契约因此建立了客户对象可以对服务器对象做出的所有假定。换言之，这份契约包含了对象的责任，即它的可靠的行为。  
单独来看，构成这份契约的每个操作都有一个唯一的签名，包含它所有的正式参数和返回值。我们把客户对象可以调用的整个操作集，以及这些操作合法的调用顺序，称为它的"协议"。协议表明了对象的动作和反应的方式，从而构成了抽象的完整静态和动态外部视图。  
抽象思想的核心是不变性的概念。"不变量"（invariant）是某种布尔（真或假）条件，它的值必须保持不变。对于对象的每个操作，我们可以定义"前置条件"（precondition）（操作假定的不变量）和“后置条件”（postcondition）（操作满足的不变量）。违反一个不变量将破坏一个抽象相关的契约。如果违反了前置条件，这意味着客户没有完成它那部分的责任，因此服务器不能可靠地执行。类似地，如果违反了后置条件，这意味着服务器没有完成它那部分的责任，所以客户不能再信任服务器的行为。出现异常表明某个不变量没有满足或不能满足。某些语言允许对象抛出异常，这样就可以中止处理，向其他对象报告问题，然后这些对象就可以捕捉异常并处理问题。



