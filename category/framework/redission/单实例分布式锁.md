
> 该锁只针对单实例有效,且不可重入

## 加锁
> 加锁是通过 set key value nx px 实现的,nx 代表key存在的时候不设置值,返回0。如果key不存在则设置值,返回1。px 则是代表超时时间,单位是毫秒

## 解锁
> 解锁是通过lua脚本操作，使用lua脚本是为了解锁的原子性 先判断当前锁的字符串是否与传入的值相等，是的话就删除Key，解锁成功

```lua
if redis.call('get',KEYS[1]) == ARGV[1] then 
   return redis.call('del',KEYS[1]) 
else
   return 0 
end
```

## 示例代码
```java
package com.broadu.common.redis;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.RedisStringCommands;
import org.springframework.data.redis.connection.ReturnType;
import org.springframework.data.redis.core.RedisCallback;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.types.Expiration;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * redis分布式锁
 *
 * @author 端木超群
 * @date 2020/11/30
 */
@Slf4j
@Component
public class RedisDistributedLock {
    /**
     * redis模板类注入
     */
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 超时时间
     */
    private static final Long TIMEOUT_MILLIS = 60 * 1000L;

    /**
     * lua释放锁语句
     */
    private static final String UNLOCK_LUA = "if redis.call('get',KEYS[1]) == ARGV[1] then " +
            "return redis.call('del',KEYS[1]) else return 0 end";

    /**
     * 线程变量
     */
    private final ThreadLocal<String> lockFlag = new ThreadLocal<>();

    /**
     * 获取redis分布式锁
     *
     * @param key 加锁的key
     * @return 获取成功/失败
     */
    public boolean getLock(String key) {
        try {
            RedisCallback<Boolean> redisCallback = connection -> {
                String uuid = UUID.randomUUID().toString();
                log.info("获取redis分布式锁uuid:{}", uuid);
                lockFlag.set(uuid);
                return connection.set(key.getBytes(StandardCharsets.UTF_8), uuid.getBytes(StandardCharsets.UTF_8),
                        Expiration.milliseconds(TIMEOUT_MILLIS), RedisStringCommands.SetOption.SET_IF_ABSENT);
            };
            return Boolean.TRUE.equals(redisTemplate.execute(redisCallback));
        } catch (Exception e) {
            log.error("获取redis分布式锁失败，失败原因：{}", e.getMessage());
        }
        return false;
    }

    /**
     * 释放redis分布式锁
     *
     * @param key 加锁的key
     * @return 释放成功/失败
     */
    public boolean releaseLock(String key) {
        try {
            RedisCallback<Boolean> redisCallback = connection -> {
                String lockValue = lockFlag.get();
                log.info("获取redis分布式锁uuid：{}", lockValue);
                return connection.eval(UNLOCK_LUA.getBytes(), ReturnType.BOOLEAN, 1,
                        key.getBytes(StandardCharsets.UTF_8), lockValue.getBytes(StandardCharsets.UTF_8));
            };
            return Boolean.TRUE.equals(redisTemplate.execute(redisCallback));
        } catch (Exception e) {
            log.error("获取redis分布式锁失败，失败原因：{}", e.getMessage());
        } finally {
            lockFlag.remove();
        }
        return false;
    }
}
```

> 理解:  
    1、通过set nx px 这种方式生成的锁首先会具有单实例的问题(同RedissonLock)。假设当前redis是多台机器做master-slave。当在一个client在master上获取到锁,master挂掉之后,slave选举成功master, 由于加锁的key未完成同步,其他client 也会有机会加锁成功，执行业务代码,因此此时会有>=2个client执行了业务代码,不满足分布式锁的原则   
    2、由于使用set nx px 的形式,超时时间在具体使用的时候就会进行指定，且仅仅指定一次。如果业务的执行时间大于指定的超时时间就会出现业务代码未执行完成,redis中的key已经释放(锁释放).其他client也有机会进行加锁成功执行。在 RedissonLock 中通过另起一个线程进行续约的操作(**看门狗**) 后台起一个定时任务的线程，每隔一定时间对该锁进行续命，延长锁的时间来避免这个问题
    