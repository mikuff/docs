## tryLock()
> tryLock() 仅仅会在空闲的时候获取到锁。如果可用，则获取锁，并立即返回true,如果不可用则立即返回false。**及时加锁, 及时失败**。


### 测试代码
```java
@SpringBootTest
@Slf4j
public class RedissonTestApplicationTests {

    @Autowired
    private RedissonClient redisson;

    /*
     * @Author lwl
     * @Description tryLock无参数、单线程测试
     * @Date 2022/8/9 10:05
     * @param
     * @Return void
     **/
    @Test
    void testTryLockNoArgsBySimpleThread() throws InterruptedException {
        RLock lock = redisson.getLock("DEMO_3");
        try {
            log.info(Thread.currentThread().getName() + ",获取到锁");
            boolean b = lock.tryLock();
            if (b) {
                log.info(Thread.currentThread().getName() + ",加锁成功");
            } else {
                log.info(Thread.currentThread().getName() + ",加锁失败");
            }

            Thread.sleep(5 * 1000);
        } finally {
            log.info(Thread.currentThread().getName() + ",释放锁");
            lock.unlock();
        }
    }

    /*
     * @Author lwl
     * @Description tryLock无参数、多线程测试
     * @Date 2022/8/9 10:05
     * @param
     * @Return void
     **/
    @Test
    void testTryLockNoArgsByMultipleThread() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 3; i++) {
            Runnable runnable = () -> {
                try {
                    RLock lock = redisson.getLock("DEMO_3");
                    boolean b = lock.tryLock();
                    if (b) {
                        log.info(Thread.currentThread().getName() + ",加锁成功");
                    } else {
                        log.info(Thread.currentThread().getName() + ",加锁失败");
                    }

                } catch (Exception e) {
                    log.info(Thread.currentThread().getName() + "," + e.getLocalizedMessage());
                }
            };
            executorService.submit(runnable);
        }
        executorService.shutdown();
        log.info("开始执行");
        latch.countDown();
        Thread.sleep(100000);
    }
}
```

### 测试结果
``` log
2022-08-09 10:07:37.930  INFO 23048 --- [           main] c.e.r.RedissonTestApplicationTests       : 开始执行
2022-08-09 10:07:37.970  INFO 23048 --- [pool-1-thread-3] c.e.r.RedissonTestApplicationTests       : pool-1-thread-3,加锁失败
2022-08-09 10:07:37.970  INFO 23048 --- [pool-1-thread-1] c.e.r.RedissonTestApplicationTests       : pool-1-thread-1,加锁失败
2022-08-09 10:07:37.971  INFO 23048 --- [pool-1-thread-2] c.e.r.RedissonTestApplicationTests       : pool-1-thread-2,加锁成功
```

### 源码分析
```java
public class RedissonLock extends RedissonExpirable implements RLock {

    @Override
    public boolean tryLock() {
        return get(tryLockAsync());
    }

    @Override
    public RFuture<Boolean> tryLockAsync() {
        return tryLockAsync(Thread.currentThread().getId());
    }

    @Override
    public RFuture<Boolean> tryLockAsync(long threadId) {
        return tryAcquireOnceAsync(-1, null, threadId);
    }

    // 加锁仅进行一次，成功则成功，失败则失败
    private RFuture<Boolean> tryAcquireOnceAsync(long leaseTime, TimeUnit unit, long threadId) {
        if (leaseTime != -1) {
            return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);
        }
        
        // tryLock() 加锁的实际逻辑走的是 tryLockInnerAsync 这个方法
        RFuture<Boolean> ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);
        ttlRemainingFuture.onComplete((ttlRemaining, e) -> {
            if (e != null) {
                return;
            }

            // 加锁成功并且获取到锁之后,执行锁续期操作
            if (ttlRemaining) {
                scheduleExpirationRenewal(threadId);
            }
        });
        return ttlRemainingFuture;
    }

}

```

#### 加锁
```java
<T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
        internalLockLeaseTime = unit.toMillis(leaseTime);

        return evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                "if (redis.call('exists', KEYS[1]) == 0) then " +
                        "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                        "return nil; " +
                        "end; " +
                        "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                        "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                        "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                        "return nil; " +
                        "end; " +
                        "return redis.call('pttl', KEYS[1]);",
                Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
    }
```
> 加锁的主要逻辑就是这段lua代码,传入的参数: KEYS[1]是传入的key名称,ARGV[1]是锁的租约时间 默认是30S,ARGV(2)是锁名称(uuid+:+线程ID)

    - 先用exists key命令判断是否锁是否被占据了，没有的话就用hset命令写入，key为锁的名称，field为"客户端唯一ID:线程ID"，value为1
    - 锁被占据了，判断是否是当前线程占据的，是的话value值加1
    - 锁不是被当前线程占据，返回锁剩下的过期时长
> **用了redis的Hash结构存储数据，如果发现当前线程已经持有锁了，就用hincrby命令将value值加1，value的值将决定释放锁的时候调用解锁命令的次数，达到实现锁的可重入性效果**

#### 续期
```java
 private void scheduleExpirationRenewal(long threadId) {
    ExpirationEntry entry = new ExpirationEntry();
    ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
    if (oldEntry != null) {
        oldEntry.addThreadId(threadId);
    } else {
        entry.addThreadId(threadId);
        renewExpiration();
    }
}

private void renewExpiration() {
    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());
    if (ee == null) {
        return;
    }
    
    Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() {
        @Override
        public void run(Timeout timeout) throws Exception {
            ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());
            if (ent == null) {
                return;
            }
            Long threadId = ent.getFirstThreadId();
            if (threadId == null) {
                return;
            }
            
            RFuture<Boolean> future = renewExpirationAsync(threadId);
            future.onComplete((res, e) -> {
                if (e != null) {
                    log.error("Can't update lock " + getName() + " expiration", e);
                    return;
                }
                
                if (res) {
                    // reschedule itself
                    renewExpiration();
                }
            });
        }
    }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
    
    ee.setTimeout(task);
}

protected RFuture<Boolean> renewExpirationAsync(long threadId) {
    return evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
            "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                    "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                    "return 1; " +
                    "end; " +
                    "return 0;",
            Collections.singletonList(getName()),
            internalLockLeaseTime, getLockName(threadId));
}
```
> 当添加锁成功之后,为了避免任务没有执行完成,而导致redis中hashfield过期失效,因此加锁成功之后需要给锁添加续期的操作    
> 代码逻辑中可以很明确的体现除起了一个异步线程，线程通过每10秒钟的方式会对锁field 进行续期。假设key锁field因为其他某种原因从redis中消失了(过期、其他redis客户端释放了锁)，异步线程就不会在进行续期   
> 虽然tryLock()无参数是及时加锁，及时释放，**但是也表名 redission的设计思想中，只要加锁成功，就会进行续约操作**

## tryLock(long waitTime, long leaseTime, TimeUnit unit)
> 这里的三个参数,等待时间(waitTime),租约时间(leaseTime),时间单位类型
- 等待时间是指在加锁过程中整体的代码执行时间(包括自旋)
- 租约时间是指在redis中被加锁的key的过期时间

```java
public class RedissonLock extends RedissonExpirable implements RLock {
    @Override
    public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
        long time = unit.toMillis(waitTime);
        long current = System.currentTimeMillis();
        long threadId = Thread.currentThread().getId();

        // 尝试进行加锁，如果加锁成功tryAcquire()返回的是null值,加锁失败返回的是redis中锁的过期时间. 
        Long ttl = tryAcquire(leaseTime, unit, threadId);
        // lock acquired
        if (ttl == null) {
            return true;
        }
        
        // 如果加锁的时间超过了设置的等待时间,则判定加锁失败, 直接return false
        time -= System.currentTimeMillis() - current;
        if (time <= 0) {
            acquireFailed(threadId);
            return false;
        }
        
        // 尝试进行订阅, 如果订阅超时且订阅成功就取消订阅,判定加锁失败 return false
        current = System.currentTimeMillis();
        RFuture<RedissonLockEntry> subscribeFuture = subscribe(threadId);
        if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) {
            if (!subscribeFuture.cancel(false)) {
                subscribeFuture.onComplete((res, e) -> {
                    if (e == null) {
                        unsubscribe(subscribeFuture, threadId);
                    }
                });
            }
            acquireFailed(threadId);
            return false;
        }

        try {
            // 再次计算时间,time(剩余时间) - 订阅时间,如果剩余时间小于等于0,则判定加锁失败，return false
            time -= System.currentTimeMillis() - current;
            if (time <= 0) {
                acquireFailed(threadId);
                return false;
            }

            // 自旋进行尝试加锁
            while (true) {
                
                // 再次尝试进行加锁，如果加锁成功则返回true,如果失败则返回加锁的key的还有多少时间过期
                long currentTime = System.currentTimeMillis();
                ttl = tryAcquire(leaseTime, unit, threadId);
                if (ttl == null) {
                    return true;
                }

                // 计算代码执行时间，如果到目前为止代码执行时间超过等待时间,则判定加锁失败,return false
                time -= System.currentTimeMillis() - currentTime;
                if (time <= 0) {
                    acquireFailed(threadId);
                    return false;
                }

                // 如果key的过期时间大于0 && 过期时间小于剩余的等待时间,则以过期时间为最大时间进行加锁，反之则以剩余等待时间为最大时间进行加锁
                currentTime = System.currentTimeMillis();
                if (ttl >= 0 && ttl < time) {
                    subscribeFuture.getNow().getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
                } else {
                    subscribeFuture.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);
                }

                // 如果剩余时间小于0则就判定加锁失败，return false
                time -= System.currentTimeMillis() - currentTime;
                if (time <= 0) {
                    acquireFailed(threadId);
                    return false;
                }
            }
        } finally {
            // 如果代码执行中出现异常就取消订阅,用于兜底的情况处理
            unsubscribe(subscribeFuture, threadId);
        }
    }
}
```
> 可以看出加锁的主体逻辑是 **初始加锁 -> 订阅 -> 自旋加锁 -> 兜底取消订阅,在整个逻辑中贯穿waitTime时间限制**
### 加锁

### 订阅

### 自旋

